import * from "lexer";
import * from "grammar";

lexer {
	start: root

	[root]
		- when r:{--[^\n]*} tag "comment" highlight "comment"
		- when r:{\/\*[\s\S]*?\*\/} tag "comment" highlight "comment"
		- when r:{\n} tag "newline"
		- import keywords
		- when r:{\d+} tag "digits" highlight "number"
		- when r:{"(?:\\["bfnrt\/\\]|\\u[a-fA-F0-9]{4}|[^"\\])*"} tag "string"
		- when r:{\/(?:[^\/\\\r\n]|\\.)+\/[gmiy]*} tag "regex" highlight "regexp"
		- when r:{[_a-zA-Z][_a-zA-Z\d]*} tag "word"
		- when "==" tag "l_eqeq" highlight "keyword"
		- when ">=" tag "l_gteq" highlight "keyword"
		- when "<=" tag "l_lteq" highlight "keyword"
		- when "=" tag "l_eq"
		- when ">" tag "l_gt" highlight "keyword"
		- when "<" tag "l_lt" highlight "keyword"
		- when "+" tag "l_add" highlight "keyword"
		- when "-" tag "l_sub" highlight "keyword"
		- when "/" tag "l_div" highlight "keyword"
		- when "%" tag "l_mod" highlight "keyword"
		- when "*" tag "l_mul" highlight "keyword"
		- when "^" tag "l_exp" highlight "keyword"
		- when ";" tag "l_semi" highlight "keyword"
		- when ":" tag "l_col" highlight "keyword"
		- when "!" tag "l_exc" highlight "keyword"
		- when "&" tag "l_band" highlight "keyword"
		- when "||" tag "l_bor" highlight "keyword"
		- when "|" tag "l_bor" highlight "keyword"
		- when "^" tag "l_exp" highlight "keyword"
		- when "." tag "l_dot"
		- when "," tag "l_comma" highlight "delimiter"
		- when "$" tag "l_m" highlight "keyword"
		- when "(" tag "l_lparen" highlight "delimiter"
		- when ")" tag "l_rparen" highlight "delimiter"
		- when "{" tag "l_lcurly" highlight "delimiter"
		- when "}" tag "l_rcurly" highlight "delimiter"
		- when "[" tag "l_lbrack" highlight "delimiter"
		- when "]" tag "l_rbrack" highlight "delimiter"
		- when r:{[ \t\r]+} tag "ws"

	[keywords]
		- when r:{var\b} tag "keyword" highlight "keyword"
		- when r:{function\b} tag "keyword" highlight "keyword"
		- when r:{true\b} tag "keyword" highlight "keyword"
		- when r:{false\b} tag "keyword" highlight "keyword"
		- when r:{null\b} tag "keyword" highlight "keyword"
		- when r:{and\b} tag "keyword" highlight "keyword"
		- when r:{or\b} tag "keyword" highlight "keyword"
		- when r:{on\b} tag "keyword" highlight "keyword"
		- when r:{if\b} tag "keyword" highlight "keyword"
		- when r:{in\b} tag "keyword" highlight "keyword"
		- when r:{each\b} tag "keyword" highlight "keyword"
		- when r:{else\b} tag "keyword" highlight "keyword"
		- when r:{for\b} tag "keyword" highlight "keyword"
		- when r:{not\b} tag "keyword" highlight "keyword"
		- when r:{while\b} tag "keyword" highlight "keyword"
		- when r:{IS\b} tag "keyword" highlight "keyword"
		- when r:{IN\b} tag "keyword" highlight "keyword"
		- when r:{LIKE\b} tag "keyword" highlight "keyword"
		- when r:{BETWEEN\b} tag "keyword" highlight "keyword"
		- when r:{AND\b} tag "keyword" highlight "keyword"
		- when r:{OR\b} tag "keyword" highlight "keyword"
		- when r:{NOT\b} tag "keyword" highlight "keyword"
		- when r:{TRUE\b} tag "keyword" highlight "keyword"
		- when r:{FALSE\b} tag "keyword" highlight "keyword"
		- when r:{NULL\b} tag "keyword" highlight "keyword"
		- when r:{CASE\b} tag "keyword" highlight "keyword"
		- when r:{WHEN\b} tag "keyword" highlight "keyword"
		- when r:{THEN\b} tag "keyword" highlight "keyword"
		- when r:{ELSE\b} tag "keyword" highlight "keyword"
		- when r:{END\b} tag "keyword" highlight "keyword"
		- when r:{IF\b} tag "keyword" highlight "keyword"
		- when r:{COALESCE\b} tag "keyword" highlight "keyword"
		- when r:{NULLIF\b} tag "keyword" highlight "keyword"
		- when r:{STRUCT\b} tag "keyword" highlight "keyword"
		- when r:{ARRAY\b} tag "keyword" highlight "keyword"
		- when r:{EXTRACT\b} tag "keyword" highlight "keyword"
		- when r:{CAST\b} tag "keyword" highlight "keyword"
}

grammar {
	// Required to say the start of the grammer parse is the [main] rule.
    start: main
	
	// Allows white space ane new lines before the start.
	[main]
		| _ section_list _ => ( $1 )

	// Is made up of sections each can be seperated by unlimited white space, comments, and new lines.
	[section_list]
		| section => ( [$0] )
		| section_list separator section => ( $0.concat($2) )

	// We only support private and public functions.
	[section]
		| PrivateScalarFunction => ( $0 )
		| PublicScalarFunction => ( $0 )

	[PrivateScalarFunction]
        | "CREATE" _ ("TEMP" | "PRIVATE") _ "FUNCTION" _ <word> "(" FunctionParams? ")" _ "RETURNS" _ DataType _ "AS" _ "(" _ Expression _ ")" ";" => (
            new CreateFunctionStmt(
                $2[0].value === "PRIVATE",
                [$2[0].value],
                $6.value,
                $8 || [],
                $13,
                null, // determinism
                null, // language
                [],   // options
                $19
            )
        )

	[PublicScalarFunction]
        | "CREATE" _ "PUBLIC" _ "FUNCTION" _ <word> "(" FunctionParams? ")" _ "RETURNS" _ DataType _ "AS" _ "(" _ Expression _ ")" ";" => (
            new CreateFunctionStmt(
                false,
                ["PUBLIC"],
                $6.value,
                $8 || [],
                $13,
                null, // determinism
                null, // language
                [],   // options
                $19
            )
        )

	[FunctionParams]
		| FunctionParam => ( [$0] )
		| FunctionParams "," __ FunctionParam => ( $0.concat([$3]) )
	
	[FunctionParam]
		| <word> __ DataType => ( new FunctionParam($0.value, $2) )

	[DataType]
        | "ARRAY" __ "<" __ DataType __ ">"
        | "STRUCT" __ "<" __ StructFields __ ">"
        | "STRING" __ "(" __ <digits> __ ")"
        | "BYTES" __ "(" __ <digits> __ ")"
        | "NUMERIC" __ "(" __ <digits> __ ("," __ <digits>)? __ ")"
        | "BIGNUMERIC" __ "(" __ <digits> __ ("," __ <digits>)? __ ")"
        | "BOOL" => ( new SimpleType(SimpleTypeKind.BOOL) )
        | "DATE" => ( new SimpleType(SimpleTypeKind.DATE) )
        | "DATETIME" => ( new SimpleType(SimpleTypeKind.DATETIME) )
        | "FLOAT64" => ( new SimpleType(SimpleTypeKind.FLOAT64) )
        | "GEOGRAPHY" => ( new SimpleType(SimpleTypeKind.GEOGRAPHY) )
        | "INT64" => ( new SimpleType(SimpleTypeKind.INT64) )
        | "INTERVAL" => ( new SimpleType(SimpleTypeKind.INTERVAL) )
        | "JSON" => ( new SimpleType(SimpleTypeKind.JSON) )
        | "NUMERIC" => ( new SimpleType(SimpleTypeKind.NUMERIC) )
        | "RANGE"
        | "STRING" => ( new SimpleType(SimpleTypeKind.STRING) )
        | "STRUCT"
        | "TIME" => ( new SimpleType(SimpleTypeKind.TIME) )
        | "TIMESTAMP" => ( new SimpleType(SimpleTypeKind.TIMESTAMP) )

    [StructFields]
        | StructField ("," __ StructField)*

    [StructField]
        | <word> __ DataType
        | DataType

	// TODO: implement scalar expressions.
	[Expression]
		| OrExpression => ( $0 )

	[OrExpression]
		| AndExpression => ( $0 )
		| OrExpression __ "OR" __ AndExpression => ( new Binary($0, BinaryOperator.OR, $4) )

	[AndExpression]
		| NotExpression => ( $0 )
		| AndExpression __ "AND" __ NotExpression => ( new Binary($0, BinaryOperator.AND, $4) )

	[NotExpression]
		| "NOT" __ NotExpression => ( new Unary(UnaryOperator.NOT, $2) )
		| ComparisonExpression => ( $0 )

	[ComparisonExpression]
		| BitwiseOrExpression => ( $0 )
		| BitwiseOrExpression __ ComparisonOp __ BitwiseOrExpression => ( new Binary($0, $2, $4) )
		| BitwiseOrExpression __ "IS" __ ("NOT" __)? "NULL" => ( new IsNullExpr($0, !!$4) )
		| BitwiseOrExpression __ "IS" __ ("NOT" __)? "TRUE" => ( new IsBoolExpr($0, !!$4, true) )
		| BitwiseOrExpression __ "IS" __ ("NOT" __)? "FALSE" => ( new IsBoolExpr($0, !!$4, false) )
		| BitwiseOrExpression _ ("NOT" _)? "IN" _ "(" _ ExpressionList _ ")" => ( new InExpr($0, !!$2, $7) )
		| BitwiseOrExpression __ ("NOT" __)? "LIKE" __ BitwiseOrExpression => ( new LikeExpr($0, !!$2, $5) )
		| BitwiseOrExpression __ ("NOT" __)? "BETWEEN" __ BitwiseOrExpression __ "AND" __ BitwiseOrExpression => ( new BetweenExpr($0, !!$2, $5, $9) )

	[ComparisonOp]
		| "=" => ( BinaryOperator.EQUALS )
		| "!=" => ( BinaryOperator.NOT_EQUALS )
		| "<>" => ( BinaryOperator.NOT_EQUALS )
		| "<" => ( BinaryOperator.LESS_THAN )
		| "<=" => ( BinaryOperator.LESS_THAN_OR_EQUAL )
		| ">" => ( BinaryOperator.GREATER_THAN )
		| ">=" => ( BinaryOperator.GREATER_THAN_OR_EQUAL )

	[BitwiseOrExpression]
		| BitwiseXorExpression => ( $0 )
		| BitwiseOrExpression __ "|" __ BitwiseXorExpression => ( new Binary($0, BinaryOperator.BITWISE_OR, $4) )

	[BitwiseXorExpression]
		| BitwiseAndExpression => ( $0 )
		| BitwiseXorExpression __ "^" __ BitwiseAndExpression => ( new Binary($0, BinaryOperator.BITWISE_XOR, $4) )

	[BitwiseAndExpression]
		| BitwiseShiftExpression => ( $0 )
		| BitwiseAndExpression __ "&" __ BitwiseShiftExpression => ( new Binary($0, BinaryOperator.BITWISE_AND, $4) )

	[BitwiseShiftExpression]
		| AdditiveExpression => ( $0 )
		| BitwiseShiftExpression __ "<<" __ AdditiveExpression => ( new Binary($0, BinaryOperator.BITWISE_LEFT_SHIFT, $4) )
		| BitwiseShiftExpression __ ">>" __ AdditiveExpression => ( new Binary($0, BinaryOperator.BITWISE_RIGHT_SHIFT, $4) )

	[AdditiveExpression]
		| MultiplicativeExpression => ( $0 )
		| AdditiveExpression __ "+" __ MultiplicativeExpression => ( new Binary($0, BinaryOperator.PLUS, $4) )
		| AdditiveExpression __ "-" __ MultiplicativeExpression => ( new Binary($0, BinaryOperator.MINUS, $4) )

	[MultiplicativeExpression]
		| UnaryExpression => ( $0 )
		| MultiplicativeExpression __ "*" __ UnaryExpression => ( new Binary($0, BinaryOperator.MULTIPLY, $4) )
		| MultiplicativeExpression __ "/" __ UnaryExpression => ( new Binary($0, BinaryOperator.DIVIDE, $4) )
		| MultiplicativeExpression __ "||" __ UnaryExpression => ( new Binary($0, BinaryOperator.CONCAT, $4) )

	[UnaryExpression]
		| "+" _ UnaryExpression => ( new Unary(UnaryOperator.PLUS, $2) )
		| "-" _ UnaryExpression => ( new Unary(UnaryOperator.MINUS, $2) )
		| "~" _ UnaryExpression => ( new Unary(UnaryOperator.BITWISE_NOT, $2) )
		| PostfixExpression => ( $0 )

	[PostfixExpression]
		| PrimaryExpression => ( $0 )
		| PostfixExpression "." <word>
		| PostfixExpression "[" __ Expression __ "]"
		| PostfixExpression "[" __ "OFFSET" "(" __ Expression __ ")" __ "]"
		| PostfixExpression "[" __ "ORDINAL" "(" __ Expression __ ")" __ "]"

	[PrimaryExpression]
		| Literal => ( $0 )
		| Identifier => ( $0 )
		| "(" _ Expression _ ")" => ( $2 )
		| "CAST" "(" __ Expression __ "AS" __ DataType __ ")"
		| "CASE" _ Expression _ CaseWhenClauses _ ("ELSE" _ Expression)? _ "END" => (
			new CaseExpr(
				$4,
				$6 ? $6[2] : null
			)
		)

	[CaseWhenClauses]
		| "WHEN" _ Expression _ "THEN" _ Expression => ( [{ condition: $2, result: $6 }] )
		| CaseWhenClauses _ "WHEN" _ Expression _ "THEN" _ Expression => ( $0.concat([{ condition: $4, result: $8 }]) )

	[Identifier]
		| <word> => ( new Variable($0.value) )

	[ExpressionList]
		| Expression => ( [$0] )
		| ExpressionList _ "," _ Expression => ( $0.concat([$4]) )

	[Literal]
		| <digits> => ( new Literal(LiteralKind.INT, $0.value) )
		| <string> => ( new Literal(LiteralKind.STRING, $0.value) )

	// Optional whitespace rule
	[_]
		| ( __ | <comment> | <newline> )*

	// Required whitespace rule
	[__]
		| <ws> => ( null )

	// Seperator rule that allows multiple whitespaace, comments, or new lines
    [separator]
        | ( __ | <comment> | <newline> )+
}
